You are working on the IWRITE project.

Current status (from your last summary):
- Auth + subscription logic + FREE/PAID plans + daily limits are complete and stable.
- The Settings page is implemented with:
  - Plan type display (FREE/PRO)
  - Usage statistics (daily usage bar)
  - Upgrade banner / calls to action
- There is a Plans page (`/plans`) with basic plan cards and ‚ÄúSelect / Upgrade‚Äù buttons.
- HOWEVER: The **upgrade flow is NOT yet wired** to an actual payment provider:
  - No Stripe checkout session
  - No upgrade endpoint that persists the plan change
  - No integration with Stripe webhooks or successful payment callbacks

üéØ HIGH-LEVEL GOAL

Carefully implement a **minimal, production-ready Stripe-based upgrade flow** that:

1) Uses Stripe Checkout (hosted payment page) for simplicity.
2) Supports:
   - One paid plan at 14.99/month (and optionally a yearly plan).
3) Upgrades the current logged-in user‚Äôs plan from FREE ‚Üí PRO after successful payment.
4) Integrates with the existing plan model (FREE vs PRO_MONTHLY/PRO_YEARLY) **without renaming or breaking anything**.
5) Wires the Upgrade button in Settings and the /plans page to this flow.
6) Updates DEPLOYMENT.md with the new Stripe env vars and instructions.

Do NOT redesign or break the existing app. Extend it in a minimal, clean, and safe way.

---

üß© PART 1 ‚Äî STRIPE CONFIG & ENV VARS

1) Use Stripe‚Äôs official Node SDK.
   - If it is not yet installed:
     - Add it via package.json (`stripe` npm package), respecting Replit‚Äôs environment.
   - Do NOT hardcode any keys.

2) Define the following environment variables (in code, just reference them via process.env; do NOT put actual keys):

   - `STRIPE_SECRET_KEY`              ‚Üí Stripe secret key
   - `STRIPE_PUBLIC_KEY`             ‚Üí Stripe publishable key (for frontend if needed)
   - `STRIPE_PRICE_ID_MONTHLY`       ‚Üí Price ID for the 14.99/month plan
   - `STRIPE_PRICE_ID_YEARLY`        ‚Üí (optional) Price ID for yearly plan if we support it
   - `STRIPE_WEBHOOK_SECRET`         ‚Üí For webhook signature verification (if implementing webhooks)

3) Add these vars to DEPLOYMENT.md:

   - Document each variable, what it does, and an example format (no real keys).
   - Make it clear that they must be configured in the production environment.

---

üß© PART 2 ‚Äî BACKEND: CHECKOUT & UPGRADE ENDPOINTS

Implement a minimal set of backend routes under e.g. `/api/billing` or `/api/stripe`. Choose names that match the current routing style; do NOT conflict with existing routes.

1) `POST /api/billing/create-checkout-session`

   - Authenticated endpoint (user must be logged in).
   - Request body:
     - Plan type (e.g. `"monthly"` or `"yearly"`).
   - Behavior:
     - Read the current user (from auth middleware).
     - Create a Stripe Checkout Session:
       - Mode: `subscription` (or `payment` + recurring as needed, but subscription is recommended).
       - Line items:
         - Use `STRIPE_PRICE_ID_MONTHLY` or `STRIPE_PRICE_ID_YEARLY` based on request.
       - Success URL:
         - Something like: `${FRONTEND_URL}/upgrade/success?session_id={CHECKOUT_SESSION_ID}`
       - Cancel URL:
         - Something like: `${FRONTEND_URL}/plans?canceled=true`
       - Pass the current user ID in `client_reference_id` or in `metadata`.
     - Return the `url` of the Checkout Session to the frontend.

2) Webhook or Polling Strategy

   For simplicity and to avoid unnecessary complexity on Replit:

   - Option A (Preferred if possible): Stripe Webhook
     - Implement `POST /api/billing/webhook`:
       - Verify Stripe signature using `STRIPE_WEBHOOK_SECRET`.
       - On successful `checkout.session.completed` / `invoice.paid` event:
         - Read `client_reference_id` or `session.customer_email` / metadata to identify user.
         - Update user‚Äôs plan in the DB to the proper PRO plan (`PRO_MONTHLY` or `PRO_YEARLY`).
         - Set `plan_started_at` and `plan_expires_at` (if applicable).
       - Return 200 on success.

   - Option B (Simpler fallback): Success page + polling
     - After redirect to success URL, the frontend calls an endpoint to:
       - Look up the Checkout Session by `session_id`.
       - If paid, update the user‚Äôs plan.
     - This can be acceptable for v1 if webhook integration is complicated in Replit.

   Choose the approach that best fits the current architecture and Replit environment, but make sure the logic is clear and documented.

3) `GET /api/billing/status` (Optional but useful)

   - Authenticated endpoint.
   - Returns:
     - Current user plan
     - Billing status (e.g. active, canceled, etc. if you track it)
   - This can simply proxy data from the `users` table, no need to query Stripe in real-time.

4) Plan Update Logic

   - Reuse the existing plan model:
     - FREE vs PRO_MONTHLY / PRO_YEARLY (or equivalent).
   - Create a single helper function to **upgrade** a user:
     - `upgradeUserToPlan(userId, planType)`.
   - This helper:
     - Updates the user‚Äôs plan field.
     - Sets start date.
     - Optionally sets expiry date (for monthly/yearly subscription if you track it).

   - Do NOT break the daily limit logic:
     - FREE users remain restricted.
     - Once upgraded to PRO, they should bypass the limit.

---

üß© PART 3 ‚Äî FRONTEND: UPGRADE FLOW WIRING

1) Settings Page

   - In the Subscription / Billing section of the Settings page:
     - Add a clear ‚ÄúUpgrade to PRO‚Äù button for FREE users.
     - When clicked:
       - Open a confirmation/choice (if you support both monthly and yearly).
       - Call the `POST /api/billing/create-checkout-session` endpoint with the selected plan.
       - On success, redirect the browser to the returned `url` (Stripe Checkout).

2) `/plans` Page

   - For each plan card (especially the paid plan):
     - Wire the ‚ÄúSelect / Upgrade‚Äù button to the same create-checkout-session logic.
   - The behavior should be consistent with the Settings page:
     - Click ‚Üí create session ‚Üí redirect to Stripe.

3) Success & Cancel Handling

   - Create simple pages or views for:
     - `/upgrade/success`:
       - Show a ‚ÄúThank you‚Äù / ‚ÄúUpgrade successful‚Äù message.
       - Optionally re-fetch user data to reflect new plan (via `/auth/me`).
     - `/plans?canceled=true`:
       - Show a gentle ‚ÄúPayment canceled‚Äù message.

   - Make sure that after success:
     - If using webhook: the user‚Äôs plan is updated by the time they refresh or come back.
     - If using polling/check-status: the success page triggers the check and updates the UI accordingly.

---

üß© PART 4 ‚Äî DOCUMENTATION & SAFETY

1) DEPLOYMENT.md

   - Add a dedicated **‚ÄúStripe & Billing‚Äù** section that documents:
     - Required env vars:
       - STRIPE_SECRET_KEY
       - STRIPE_PUBLIC_KEY
       - STRIPE_PRICE_ID_MONTHLY
       - STRIPE_PRICE_ID_YEARLY (if used)
       - STRIPE_WEBHOOK_SECRET (if webhooks are implemented)
     - How to:
       - Create products/prices in Stripe.
       - Set the env vars.
       - Configure the webhook endpoint URL in the Stripe dashboard.

   - Clarify:
     - FREE vs PRO behavior.
     - That payments are handled via Stripe Checkout.

2) Safety

   - Do NOT:
     - Expose Stripe secret keys to the client.
     - Log full webhook bodies with secrets.
   - Ensure:
     - All billing routes are protected appropriately (auth where required).
     - Errors are handled gracefully with clear messages.

---

üß© PART 5 ‚Äî FINAL VERIFICATION

After implementing all of the above:

1) Run:

   ```bash
   npm run build
